<head>
    <title>kunkka-torrent - stream media to browser</title>
    <meta charset="utf-8"/>
    <link rel="icon" href="./../favicon.ico"/>
    <link rel="stylesheet" href="../styles/common.css"/>
</head>

<style>
    tbody {
        background-color: #1b325dba;
    }
    .seeders-number {
        color: lightgreen;
        text-align: right;
    }
    .leechers-number {
        color: lightcoral;
        text-align: right;
    }
    .torrent-size {
        text-align: right;
    }
    .torrent-file-name {
        font-size: 12px;
    }
</style>

<body>
    <header>
        <div class="header-text-block-space">
            <div class="header-title-with-search-form">
                <div class="header-main-title">
                    <a href="https://kunkka-torrent.online">
                        <span class="kunkka-color">kunkka</span>-<span class="torrent-color">torrent</span>
                    </a>
                </div>
                <div>
                    <form method="get" action="./search.html">
                        <input required="required" placeholder="Type file name here" name="pattern" type="text"/>
                        <select name="category">
                            <option selected value="all">All categories</option>
                            <option disabled="">──────────</option>
                            <option value="anime">Anime</option>
                            <option value="books">Books</option>
                            <option value="games">Games</option>
                            <option value="movies">Movies</option>
                            <option value="music">Music</option>
                            <option value="pictures">Pictures</option>
                            <option value="software">Software</option>
                            <option value="tv">TV shows</option>
                        </select>
                        <input type="hidden" name="plugins" value="all"/>
                        <button>Search</button>
                    </form>
                </div>
            </div>
            <p class="title-secondary-text">A web app that allows playing video/music from torrents (like popcorn time) directly in the browser, without downloading to PC</p>
        </div>
        <div class="header-image-remainder-space"></div>
    </header>

    <div id="status_text">Loading...</div>

    <table>
        <thead>
            <tr>
                <th>Name</th>
                <th>Size</th>
                <th>Leechers</th>
                <th>Seeders</th>
                <th>Magnet (Download) Link</th>
                <th>View in Tracker</th>
            </tr>
        </thead>
        <tbody id="search_results_list"></tbody>
    </table>

<script type="module">

import {Dom} from 'https://klesun-misc.github.io/dev_data/common/js/Dom.js';

const gui = {
    status_text: document.getElementById('status_text'),
    search_results_list: document.getElementById('search_results_list'),
};

const getScore = (item) => {
    if (item.siteUrl === 'https://eztv.io') {
        // returns irrelevant results if nothing matched query
        return 0;
    } else if (item.infoHash) {
        return item.nbSeeders;
    } else {
        // would still be able to fetch them most likely,
        // but will be some hassle, not implemented yet
        return item.nbSeeders / 2;
    }
};

const getInfoHash = async resultItem => {
    if (resultItem.infoHash) {
        return resultItem.infoHash;
    } else {
        throw new Error('TODO: convert torrent to info hash - ' + resultItem.fileUrl);
    }
};

const playVideo = (video, infoHash, file) => {
    video.setAttribute('data-info-hash', infoHash);
    video.setAttribute('data-file-path', file.path);
    video.setAttribute('src', '/torrent-stream?' + new URLSearchParams({
        infoHash: video.getAttribute('data-info-hash'),
        filePath: video.getAttribute('data-file-path'),
    }));
    video.innerHTML = '';
    video.play();
    // gui.video_player_popdown.classList.toggle('video-selected', true);
    // gui.selected_video_ffmpeg_info.textContent = 'It may take a minute or so before playback can be started...';
    // gui.selected_video_container_info.innerHTML = '';
    // gui.selected_video_stream_list.innerHTML = '';
    // gui.selected_video_filename.textContent = file.path;
    // gui.selected_video_size.textContent = (file.length / 1024 / 1024).toFixed(3) + ' MiB';

    const url = '/api/getFfmpegInfo?' + new URLSearchParams({
        infoHash: video.getAttribute('data-info-hash'),
        filePath: video.getAttribute('data-file-path'),
    });
    // fetch(url).then(rs => rs.json()).then((ffprobeOutput) => {
    //     if (video.getAttribute('data-info-hash') === infoHash &&
    //         video.getAttribute('data-file-path') === file.path
    //     ) {
    //         displayFfprobeOutput(ffprobeOutput, video);
    //     }
    // });
    // updateSwarmInfo = async () => {
    //     if (video.getAttribute('data-info-hash') !== infoHash || video.ended) {
    //         updateSwarmInfo = () => {};
    //     } else {
    //         const url = 'https://kunkka-torrent.online/api/getSwarmInfo?' +
    //             new URLSearchParams({infoHash});
    //         fetch(url).then(rs => rs.json()).then(swarmSummary => {
    //             gui.selected_video_ffmpeg_info.textContent = JSON.stringify(swarmSummary);
    //         });
    //     }
    // };
};

const makeFilesList = ({resultItem, infoHash, seconds, video, files}) => {
    const isBadCodec =
        resultItem.fileName.match(/265/) ||
        resultItem.fileName.match(/hevc/i) ||
        resultItem.fileName.match(/mpeg-?4/i);
    return Dom('div', {}, [
        Dom('span', {}, seconds),
        Dom('span', {}, 'Show Files:'),
        Dom('input', {type: 'checkbox', class: 'hide-following-flag'}),
        Dom('table', {}, [
            Dom('tbody', {}, files.map(f => Dom('tr', {}, [
                Dom('td', {}, f.path),
                Dom('td', {}, (f.length / 1024 / 1024).toFixed(3) + ' MiB'),
                Dom('td', {}, [
                    Dom('button', {
                        onclick: () => playVideo(video, infoHash, f),
                        ...(!isBadCodec ? {} : {
                            disabled: 'disabled',
                            style: 'cursor: help',
                            title: 'Codec of this video file (h265/hevc/mpeg4) is a proprietary piece of shit, it can not be played in the browser - you can only download it to pc and play with vlc or choose a different torrent',
                        }),
                    }, 'Watch'),
                ]),
            ]))),
        ]),
    ]);
};

const toExpandView = (resultItem, getTr) => {
    let expandedView = null;
    let whenMetaInfo = null;
    let whenInfoHash = null;
    return () => {
        const tr = getTr();
        if (expandedView) {
            expandedView.remove();
            expandedView = null;
            return;
        }
        const fileListCont = Dom('div', {}, 'Loading File List...');
        const video = Dom('video', {controls: 'controls'});
        expandedView = Dom('tr', {}, [
            Dom('td', {colspan: 999}, [
                Dom('div', {style: 'display: flex; justify-content: space-evenly'}, [
                    fileListCont,
                    Dom('div', {}, [video]),
                ]),
            ]),
        ]);
        tr.parentNode.insertBefore(expandedView, tr);
        const startedMs = Date.now();
        whenInfoHash = whenInfoHash || getInfoHash(resultItem);
        whenMetaInfo = whenMetaInfo || whenInfoHash
            .then((ih) => fetch('/api/getSwarmInfo?infoHash=' + ih))
            .then(rs => {
                if (rs.status !== 200) {
                    throw new Error(rs.statusText);
                } else {
                    return rs.json();
                }
            });
        whenMetaInfo.then(async metaInfo => {
            const seconds = (Date.now() - startedMs) / 1000;
            const infoHash = await whenInfoHash;
            const filesList = makeFilesList({
                resultItem, infoHash, seconds,
                video, files: metaInfo.files,
            });
            fileListCont.innerHTML = '';
            fileListCont.appendChild(filesList);
        });
    };
};

const makeResultTr = (resultItem) => {
    const tr = Dom('tr', {}, [
        Dom('td', {class: 'torrent-file-name'}, resultItem.fileName),
        Dom('td', {class: 'torrent-size'}, resultItem.fileSize <= 0
            ? resultItem.fileSize
            : (resultItem.fileSize / 1024 / 1024).toFixed(1) + 'MiB'),
        Dom('td', {class: 'leechers-number'}, resultItem.nbLeechers),
        Dom('td', {class: 'seeders-number'}, resultItem.nbSeeders),
        Dom('td', {}, [
            Dom('a', {
                href: resultItem.fileUrl,
            }, resultItem.infoHash || resultItem.fileUrl),
        ]),
        Dom('td', {}, [
            Dom('a', {
                href: resultItem.descrLink,
            }, new URL(resultItem.descrLink).hostname),
        ]),
        Dom('td', {}, [
            Dom('button', {
                onclick: toExpandView(resultItem, () => tr),
            }, 'Connect'),
        ]),
    ]);
    return tr;
};

const main = async () => {
    const {id} = await fetch('/api/qbtv2/search/start', {
        headers: {
            'content-type': 'application/x-www-form-urlencoded; charset=UTF-8',
        },
        'body': window.location.search.slice('?'.length),
        'method': 'POST',
    }).then(rs => {
        if (rs.status !== 200) {
            throw new Error(rs.statusText);
        } else {
            return rs.json();
        }
    });

    await new Promise(resolve => setTimeout(resolve, 3000));

    /** @type {QbtSearchResult} */
    const resultsRs = await fetch('/api/qbtv2/search/results', {
        headers: {
            'content-type': 'application/x-www-form-urlencoded; charset=UTF-8',
        },
        'body': new URLSearchParams({
            id: id, limit: 500, offset: 0,
        }).toString(),
        'method': 'POST',
    }).then(rs => {
        if (rs.status !== 200) {
            throw new Error(rs.statusText);
        } else {
            return rs.json();
        }
    });

    gui.status_text.textContent = resultsRs.status;

    const results = resultsRs.results
        // forged seed numbers, no way to exclude on API level apparently
        .filter(r => r.siteUrl !== 'https://limetor.com')
        .map(r => {
            const match = r.fileUrl.match(/^magnet:\?xt=urn:btih:([a-fA-F0-9]{40}).*/);
            if (match) {
                r.infoHash = match[1];
            }
            return r;
        })
        .sort((a,b) => getScore(b) - getScore(a));

    for (const resultItem of results) {
        const tr = makeResultTr(resultItem);
        gui.search_results_list.appendChild(tr);
    }
};

main();

</script>

</body>